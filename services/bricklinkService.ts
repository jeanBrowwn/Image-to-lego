import type { LegoPart, ValidatedLegoPart, Availability } from '../types';

// --- IMPORTANT SECURITY NOTE ---
// The BrickLink API uses OAuth 1.0a, which requires a Consumer Secret and Token Secret.
// These secrets MUST NOT be exposed in a client-side application (like this one).
// Doing so would allow anyone to steal and misuse your API credentials.
//
// THE CORRECT ARCHITECTURE:
// 1. Create a backend proxy (e.g., using a serverless function on Vercel, Netlify, or Google Cloud).
// 2. The frontend sends a request to YOUR backend proxy.
// 3. Your backend proxy securely stores the API secrets, signs the request, and forwards it to the BrickLink API.
// 4. The BrickLink API responds to your backend, which then sends the data back to the frontend.
//
// This file is structured as a high-fidelity MOCK of that service. It simulates
// the API calls that would happen on a secure backend to demonstrate functionality.

const BRICKLINK_API_CONFIG = {
  consumerKey: process.env.BRICKLINK_CONSUMER_KEY,
  consumerSecret: process.env.BRICKLINK_CONSUMER_SECRET,
  tokenValue: process.env.BRICKLINK_TOKEN_VALUE,
  tokenSecret: process.env.BRICKLINK_TOKEN_SECRET,
};

/**
 * MOCKS a call to a secure backend proxy which in turn calls the BrickLink API.
 * This function validates parts, gets real pricing, and checks availability.
 * @param parts - The list of parts generated by the AI.
 * @returns A promise that resolves to a list of validated LEGO parts.
 */
export const validateAndPriceParts = (parts: LegoPart[]): Promise<ValidatedLegoPart[]> => {

  return new Promise(resolve => {
    // Simulate network delay for a backend call
    setTimeout(() => {
      const validatedParts = parts.map((part): ValidatedLegoPart => {
        // Simulate realistic price variation (+/- 20% of AI estimate)
        const priceFluctuation = (Math.random() - 0.5) * 0.4; // -0.2 to +0.2
        const realPrice = Math.max(0.01, part.estimatedPrice * (1 + priceFluctuation));
        
        const brickLinkUrl = `https://www.bricklink.com/v2/catalog/catalogitem.page?P=${part.pieceId}`;

        // Simulate realistic availability and potential issues
        const randomAvail = Math.random();
        let availability: Availability = 'Available';
        let notes: string | undefined = undefined;

        if (part.pieceId.length < 3) { // AI sometimes hallucinates short IDs
            availability = 'Check Alternatives';
            notes = 'AI-suggested part ID seems invalid. Please verify on BrickLink.';
        } else if (randomAvail > 0.9) {
            availability = 'Check Alternatives';
            notes = 'This part/color combination may not exist. Check alternatives.';
        } else if (randomAvail > 0.8) {
            availability = 'Rare';
            notes = 'Part is rare and may be expensive or hard to find.';
        }

        return {
          ...part,
          realPrice,
          availability,
          brickLinkUrl,
          notes,
        };
      });
      resolve(validatedParts);
    }, 1500); // 1.5 second delay
  });
};
